// Generated by CoffeeScript 1.4.0
(function() {
  var DEFAULT_ENCODING, EXTRACT_PARAMS, EventEmitter, LIST_PARAMS, MAX_BUFFER_SIZE, RAR_ID, RAR_TOOL, RarFile, VERSION, VIEW_TOOL, exec, fs, isRarFile, spawn, _when,
    _this = this,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  fs = require('fs');

  spawn = require('child_process').spawn;

  exec = require('child_process').exec;

  EventEmitter = require('events').EventEmitter;

  _when = require('when');

  VERSION = '0.1.14-3';

  RAR_ID = new Buffer('Rar!\x1a\x07\x00');

  RAR_TOOL = 'unrar';

  LIST_PARAMS = ['lb'];

  EXTRACT_PARAMS = ['p', '-y', '-idq'];

  VIEW_TOOL = 'kview';

  MAX_BUFFER_SIZE = 1024 * 1024 * 10;

  DEFAULT_ENCODING = 'binary';

  isRarFile = function(filename, cb) {
    var data, n, ret, _i, _ref;
    try {
      data = fs.readFileSync(filename);
      ret = true;
      for (n = _i = 0, _ref = RAR_ID.length; 0 <= _ref ? _i < _ref : _i > _ref; n = 0 <= _ref ? ++_i : --_i) {
        if (data[n] !== RAR_ID[n]) {
          ret = false;
          break;
        }
      }
      if (cb) {
        cb(null, ret);
      }
      return ret;
    } catch (e) {
      if (cb) {
        return cb(e, null);
      } else {
        throw e;
      }
    }
  };

  RarFile = (function(_super) {

    __extends(RarFile, _super);

    RarFile.VERSION = VERSION;

    function RarFile(archiveName, options) {
      var _this = this;
      this.archiveName = archiveName;
      this.toString = __bind(this.toString, this);

      this.length = __bind(this.length, this);

      this.showFile = __bind(this.showFile, this);

      this.pipe = __bind(this.pipe, this);

      this.readFile = __bind(this.readFile, this);

      this.readStream = __bind(this.readStream, this);

      this._loadNames = __bind(this._loadNames, this);

      if (!this.archiveName) {
        throw new Error('Must provide a filename.');
      }
      this.rarTool = (options != null ? options.rarTool : void 0) || RAR_TOOL;
      this.debugMode = (options != null ? options.debugMode : void 0) || false;
      this.viewTool = (options != null ? options.viewTool : void 0) || VIEW_TOOL;
      this.faultTolerant = (options != null ? options.faultTolerant : void 0) || true;
      this._loadedList = false;
      this.names = [];
      if (!isRarFile(this.archiveName)) {
        if (!this.faultTolerant) {
          throw new Error("" + this.archiveName + " is not a RAR archive");
        }
      }
      this.on('ready', function(who) {
        if (who.debugMode) {
          return console.log(who.toString());
        }
      });
      this._loadNames().then((function(readStream) {
        var f;
        _this.names = (function() {
          var _i, _len, _ref, _results;
          _ref = readStream.split('\n');
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            f = _ref[_i];
            if (f && f !== 'undefined') {
              _results.push(f);
            }
          }
          return _results;
        })();
        _this._loadedList = true;
        return _this;
      }), (function(err) {
        if (_this.debugMode) {
          console.log("Throwing error " + (err.toString()) + " produced while loading names from the RAR archive");
        }
        throw err;
      })).then(function(self) {
        return self.emit('ready', self);
      });
    }

    RarFile.prototype._loadNames = function() {
      var deferred, executable, params,
        _this = this;
      params = "" + (LIST_PARAMS.join(' ')) + " \"" + this.archiveName + "\"";
      executable = "\"" + this.rarTool + "\" " + params;
      if (this.debugMode) {
        console.log("Running << " + executable + " >>");
      }
      deferred = _when.defer();
      exec(executable, {
        encoding: "utf8",
        maxBuffer: MAX_BUFFER_SIZE
      }, function(err, stdout, stderr) {
        if (err) {
          return deferred.reject(err);
        } else {
          return deferred.resolve(stdout);
        }
      });
      return deferred.promise;
    };

    RarFile.prototype.readStream = function(filename, options) {
      var p, params, unrar;
      params = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = EXTRACT_PARAMS.length; _i < _len; _i++) {
          p = EXTRACT_PARAMS[_i];
          _results.push(p);
        }
        return _results;
      })();
      params.push("" + this.archiveName);
      params.push("" + filename);
      if (this.debugMode) {
        console.log("Running << " + this.rarTool + " " + params + " >>");
      }
      unrar = spawn("" + this.rarTool, params);
      unrar.stdout.setEncoding('binary');
      if (!(options != null ? options.silent : void 0)) {
        this.emit('readStream', unrar.stdout);
      }
      if (this.debugMode) {
        console.log('readStream EVENT');
      }
      return unrar.stdout;
    };

    RarFile.prototype.readFile = function(filename, cb, options) {
      var _this = this;
      if (cb && cb.constructor.name === 'Object') {
        options = cb;
      }
      return (function() {
        var deferred, fdata, rStream;
        deferred = _when.defer();
        fdata = '';
        rStream = _this.readStream(filename);
        rStream.on('error', function(err) {
          return deferred.reject(err);
        });
        rStream.on('data', function(chunk) {
          return fdata += chunk;
        });
        rStream.on('end', function() {
          return deferred.resolve(fdata);
        });
        return deferred.promise;
      })().then((function(data) {
        if (!(options != null ? options.silent : void 0)) {
          _this.emit('readFile:data', data);
        }
        if (_this.debugMode) {
          console.log('readFile:data EVENT');
        }
        if (cb && cb.constructor.name === 'Function') {
          cb(null, data);
        }
        return data;
      }), (function(err) {
        if (!(options != null ? options.silent : void 0)) {
          _this.emit('readFile:error', err);
        }
        if (_this.debugMode) {
          console.log("readFile:error - " + (err.toString()));
        }
        if (cb && cb.constructor.name === 'Function') {
          cb(err, null);
        }
        return err;
      }));
    };

    RarFile.prototype.pipe = function(filename, outStream, options) {
      var err,
        _this = this;
      if (options == null) {
        options = {
          end: true
        };
      }
      if (filename.constructor.name === 'Number') {
        filename = this.names[filename];
      }
      if (!filename) {
        err = new Error('Wrong archive file');
        this.emit('pipe:error', err);
        if (this.debugMode) {
          console.log("pipe:error - " + (err.toString()));
        }
        throw err;
      }
      if ((!outStream) || (!outStream.write) || (outStream.write.constructor.name !== 'Function')) {
        err = new Error('A writable stream must be provided');
        this.emit('pipe:error', err);
        if (this.debugMode) {
          console.log("pipe:error - " + (err.toString()));
        }
        throw err;
      }
      return this.readFile(filename).then(function(data) {
        if (data.length === 0) {
          err = new Error('File does not exist in the archive');
          _this.emit('pipe:error', err);
          if (_this.debugMode) {
            console.log("pipe:error - " + (err.toString()));
          }
          throw err;
        }
        outStream.write(data, (options != null ? options.encoding : void 0) || 'binary');
        if (!!(options != null ? options.end : void 0)) {
          outStream.end();
        }
        if (!(options != null ? options.silent : void 0)) {
          _this.emit('pipe:data', outStream, data);
        }
        if (_this.debugMode) {
          console.log("pipe:data EVENT");
        }
        return data;
      });
    };

    RarFile.prototype.showFile = function(filename) {
      var _this = this;
      return this.readFile(filename, function(err, data) {
        var show;
        if (err) {
          console.log(err.toString());
          return;
        }
        fs.writeFileSync(filename, data, 'binary');
        console.log("Length of extracted data: " + data.length);
        try {
          return show = spawn(_this.viewTool, [filename]);
        } catch (e) {
          return console.log(e.toString());
        }
      });
    };

    RarFile.prototype.length = function() {
      return this.names.length;
    };

    RarFile.prototype.toString = function() {
      return JSON.stringify({
        names: this.names,
        length: this.length()
      });
    };

    return RarFile;

  })(EventEmitter);

  module.exports = {
    VERSION: VERSION,
    isRarFile: isRarFile,
    RarFile: RarFile
  };

}).call(this);
